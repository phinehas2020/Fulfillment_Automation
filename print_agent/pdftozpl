#!/usr/bin/env python3
"""
CUPS Filter: Convert PDF to ZPL for Zebra ZP 505 (203 DPI).
"""

import sys
import os
import subprocess
import shutil
import tempfile
import glob

# Constants for Zebra ZP 505
DPI = 203
WIDTH_INCH = 4
HEIGHT_INCH = 6
WIDTH_PX = int(WIDTH_INCH * DPI)
HEIGHT_PX = int(HEIGHT_INCH * DPI)

def pdf_to_zpl(pdf_file, job_id, user, title, copies, options):
    """Convert PDF to ZPL."""
    
    # Check for pdftoppm
    if not shutil.which("pdftoppm"):
        sys.stderr.write("ERROR: pdftoppm not found. Install poppler-utils.\n")
        return 1

    temp_dir = tempfile.mkdtemp(prefix="cups_zpl_")
    try:
        # Use a temporary prefix for output
        out_prefix = os.path.join(temp_dir, "page")
        
        # Determine input file
        input_file = "-" # Default to stdin
        if pdf_file and pdf_file != "-":
            input_file = pdf_file
            
        cmd = [
            "pdftoppm",
            "-mono",
            "-r", str(DPI),
            input_file,
            out_prefix
        ]
        
        # Input data handling
        # If input_file is "-", we MUST pipe data to stdin of subprocess
        # If input_file is a path, we MUST NOT pipe data
        
        stdin_stream = None
        input_data = None
        
        if input_file == "-":
            # Read from our stdin and buffer it to pass to subprocess
            # OR pass our stdin directly? Passing directly is safer for memory but subprocess needs file object
            # Let's read it to be safe against seeking issues if any
            stdin_stream = subprocess.PIPE
            input_data = sys.stdin.buffer.read()
            
            # If we read 0 bytes from stdin, and filename wasn't provided, that's the "Stream empty" error
            if len(input_data) == 0:
                 sys.stderr.write("ERROR: No input data received on stdin\n")
                 return 1
        
        # Run conversion
        p = subprocess.Popen(cmd, stdin=stdin_stream, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = p.communicate(input=input_data)
        
        if p.returncode != 0:
            sys.stderr.write(f"ERROR: pdftoppm failed: {stderr.decode()}\n")
            return 1
            
        # Find generated PBM files
        search_pattern = out_prefix + "*.pbm"
        files = glob.glob(search_pattern)
        files.sort() # Ensure page 1, 2, 3 order
        
        if not files:
             sys.stderr.write(f"ERROR: No PBM files generated in {temp_dir}\n")
             return 1

        for pbm_file in files:
            with open(pbm_file, "rb") as f:
                data = f.read()
                process_pbm_data(data)
                
    except Exception as e:
        sys.stderr.write(f"ERROR: Conversion failed: {e}\n")
        return 1
    finally:
        shutil.rmtree(temp_dir)
        
    return 0

def process_pbm_data(data):
    """Parse PBM file data and emit ZPL."""
    # PBM file format (P4)
    # Header: P4\nWidth Height\nData
    
    if len(data) < 3: return
    
    # Check for P4 magic number
    if data[:2] != b'P4':
        sys.stderr.write("ERROR: Not a P4 PBM file\n")
        return

    # Parse Header
    offset = 2
    while offset < len(data) and chr(data[offset]).isspace(): offset += 1
    
    # Skip comments if any
    while offset < len(data) and chr(data[offset]) == '#':
        while offset < len(data) and chr(data[offset]) != '\n': offset += 1
        offset += 1
        while offset < len(data) and chr(data[offset]).isspace(): offset += 1

    # Width
    w_start = offset
    while offset < len(data) and not chr(data[offset]).isspace(): offset += 1
    if offset >= len(data): return
    width = int(data[w_start:offset])
    
    while offset < len(data) and chr(data[offset]).isspace(): offset += 1
    
    # Height
    h_start = offset
    while offset < len(data) and not chr(data[offset]).isspace(): offset += 1
    if offset >= len(data): return
    height = int(data[h_start:offset])
    
    while offset < len(data) and chr(data[offset]).isspace(): offset += 1
    
    # Binary data starts here
    image_data = data[offset:]
    
    row_bytes = (width + 7) // 8
    
    # Emit
    emit_zpl(width, height, row_bytes, image_data)

def emit_zpl(width, height, row_bytes, data):
    """Output ZPL for a single image."""
    
    sys.stdout.buffer.write(b"^XA")
    sys.stdout.buffer.write(b"^PW%d" % width)
    sys.stdout.buffer.write(b"^LL%d" % height)
    sys.stdout.buffer.write(b"^PON") # Print Orientation Normal
    
    # Graphic Field
    # ^GFA,bytes,total_bytes,row_bytes,data
    # data needs to be hex encoded
    
    hex_data = data.hex().upper().encode('ascii')
    
    sys.stdout.buffer.write(b"^FO0,0^GFA,%d,%d,%d," % (len(data), len(data), row_bytes))
    sys.stdout.buffer.write(hex_data)
    sys.stdout.buffer.write(b"^FS")
    sys.stdout.buffer.write(b"^XZ\n")

if __name__ == "__main__":
    if len(sys.argv) < 6:
        sys.stderr.write("Usage: pdftozpl job-id user title copies options [file]\n")
        
    job_id = sys.argv[1] if len(sys.argv) > 1 else "1"
    user = sys.argv[2] if len(sys.argv) > 2 else "unknown"
    title = sys.argv[3] if len(sys.argv) > 3 else "untitled"
    copies = sys.argv[4] if len(sys.argv) > 4 else "1"
    options = sys.argv[5] if len(sys.argv) > 5 else ""
    filename = sys.argv[6] if len(sys.argv) > 6 else None
    
    sys.exit(pdf_to_zpl(filename, job_id, user, title, copies, options))
