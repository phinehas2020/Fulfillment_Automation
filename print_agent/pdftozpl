#!/usr/bin/env python3
"""
CUPS Filter: Convert PDF/PS to ZPL for Zebra ZP 505 (203 DPI).
"""

import sys
import os
import subprocess
import shutil
import tempfile
import glob

# Constants for Zebra ZP 505 (override with env vars if needed)
DPI = int(os.environ.get("ZPL_DPI", "203"))
WIDTH_INCH = float(os.environ.get("ZPL_WIDTH_INCH", "4"))
HEIGHT_INCH = float(os.environ.get("ZPL_HEIGHT_INCH", "6"))
WIDTH_PX = int(round(WIDTH_INCH * DPI))
HEIGHT_PX = int(round(HEIGHT_INCH * DPI))

SCALE_TO_LABEL = os.environ.get("ZPL_SCALE_TO_LABEL", "1").lower() in ("1", "true", "yes")
FIT_TO_LABEL = os.environ.get("ZPL_FIT_TO_LABEL", "1").lower() in ("1", "true", "yes")
FORCE_FIT = os.environ.get("ZPL_FORCE_FIT", "0").lower() in ("1", "true", "yes")
FORCE_CROP = os.environ.get("ZPL_FORCE_CROP", "0").lower() in ("1", "true", "yes")
INVERT_BITS = os.environ.get("ZPL_INVERT_BITS", "0").lower() in ("1", "true", "yes")
REVERSE_BITS = os.environ.get("ZPL_REVERSE_BITS", "0").lower() in ("1", "true", "yes")
AUTO_INVERT = os.environ.get("ZPL_AUTO_INVERT", "0").lower() in ("1", "true", "yes")
DEBUG = os.environ.get("ZPL_DEBUG", "0").lower() in ("1", "true", "yes")
AUTO_CROP_CONTENT = os.environ.get("ZPL_AUTO_CROP_CONTENT", "1").lower() in ("1", "true", "yes")
ROTATE_TO_FIT = os.environ.get("ZPL_ROTATE_TO_FIT", "1").lower() in ("1", "true", "yes")
CONTENT_PAD_PX = int(os.environ.get("ZPL_CONTENT_PAD_PX", "8"))
CONTENT_ZOOM = float(os.environ.get("ZPL_CONTENT_ZOOM", "1.15"))
ALLOW_UPSCALE = os.environ.get("ZPL_ALLOW_UPSCALE", "0").lower() in ("1", "true", "yes")

BIT_COUNTS = [bin(i).count("1") for i in range(256)]
REVERSE_TABLE = bytes(int(f"{i:08b}"[::-1], 2) for i in range(256))

def log(message):
    if DEBUG:
        sys.stderr.write(message + "\n")

def require_tool(name, hint):
    if shutil.which(name):
        return True
    sys.stderr.write(f"ERROR: {name} not found. {hint}\n")
    return False

def run_command(cmd, input_data=None):
    stdin_stream = subprocess.PIPE if input_data is not None else None
    p = subprocess.Popen(cmd, stdin=stdin_stream, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate(input=input_data)
    if p.returncode != 0:
        sys.stderr.write(f"ERROR: Command failed: {' '.join(cmd)}\n")
        if stderr:
            sys.stderr.write(stderr.decode(errors="ignore") + "\n")
        return False
    if DEBUG and stderr:
        log(stderr.decode(errors="ignore").strip())
    return True

def sniff_file_type(path):
    with open(path, "rb") as f:
        header = f.read(5)
    if header.startswith(b"%PDF-"):
        return "pdf"
    if header.startswith(b"%!PS"):
        return "ps"
    return "unknown"

def ps_to_pdf(ps_path, pdf_path):
    if shutil.which("gs"):
        cmd = [
            "gs",
            "-dNOPAUSE",
            "-dBATCH",
            "-sDEVICE=pdfwrite",
            f"-sOutputFile={pdf_path}",
            ps_path,
        ]
        return run_command(cmd)
    if shutil.which("ps2pdf"):
        cmd = ["ps2pdf", ps_path, pdf_path]
        return run_command(cmd)
    sys.stderr.write("ERROR: ps2pdf or gs not found. Install ghostscript.\n")
    return False

def pdf_page_size_points(pdf_path):
    if not shutil.which("pdfinfo"):
        log("pdfinfo not found; cannot detect page size")
        return None
    p = subprocess.Popen(["pdfinfo", pdf_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, _ = p.communicate()
    if p.returncode != 0:
        return None
    for line in stdout.decode(errors="ignore").splitlines():
        if line.startswith("Page size:"):
            parts = line.split()
            try:
                width = float(parts[2])
                height = float(parts[4])
                return width, height
            except (IndexError, ValueError):
                return None
    return None

def prepare_pdf_for_label(pdf_in, pdf_out):
    if not shutil.which("gs"):
        log("gs not found; skipping FIT_TO_LABEL")
        return False

    size = pdf_page_size_points(pdf_in)
    if not size:
        log("Unable to detect page size; skipping FIT_TO_LABEL")
        return False

    src_w, src_h = size
    label_w = float(WIDTH_INCH * 72)
    label_h = float(HEIGHT_INCH * 72)

    if FORCE_FIT:
        mode = "fit"
    elif FORCE_CROP:
        mode = "crop"
    else:
        if src_w > label_w or src_h > label_h:
            mode = "crop"
        elif src_w < label_w or src_h < label_h:
            mode = "fit"
        else:
            return False

    cmd = [
        "gs",
        "-sDEVICE=pdfwrite",
        "-dNOPAUSE",
        "-dBATCH",
        "-dSAFER",
        "-dFIXEDMEDIA",
        "-dAutoRotatePages=/None",
        f"-dDEVICEWIDTHPOINTS={int(round(label_w))}",
        f"-dDEVICEHEIGHTPOINTS={int(round(label_h))}",
    ]
    if mode == "fit":
        cmd.append("-dPDFFitPage")
    cmd += [f"-sOutputFile={pdf_out}", pdf_in]
    return run_command(cmd)

def render_pdf_to_pbm(pdf_path, temp_dir):
    out_prefix = os.path.join(temp_dir, "page")
    cmd = [
        "pdftoppm",
        "-mono",
        "-r", str(DPI),
    ]
    if SCALE_TO_LABEL:
        cmd += ["-scale-to-x", str(WIDTH_PX), "-scale-to-y", str(HEIGHT_PX)]
    cmd += [pdf_path, out_prefix]
    if not run_command(cmd):
        return []
    files = glob.glob(out_prefix + "*.pbm")
    files.sort()
    return files

def normalize_image_data(image_data, row_bytes, height):
    expected_len = row_bytes * height
    if len(image_data) < expected_len:
        log(f"PBM data short: {len(image_data)} < {expected_len}, padding with zeros")
        image_data = image_data + (b"\x00" * (expected_len - len(image_data)))
    elif len(image_data) > expected_len:
        log(f"PBM data long: {len(image_data)} > {expected_len}, truncating")
        image_data = image_data[:expected_len]
    return image_data

def maybe_transform_image(image_data, row_bytes, height):
    image_data = normalize_image_data(image_data, row_bytes, height)

    if REVERSE_BITS:
        image_data = image_data.translate(REVERSE_TABLE)

    if INVERT_BITS:
        image_data = bytes(b ^ 0xFF for b in image_data)
    elif AUTO_INVERT:
        total_bits = row_bytes * 8 * height
        black_bits = sum(BIT_COUNTS[b] for b in image_data)
        ratio = black_bits / total_bits if total_bits else 0.0
        log(f"Black ratio: {ratio:.3f}")
        if ratio > 0.65:
            log("Auto-inverting bitmap due to high black ratio")
            image_data = bytes(b ^ 0xFF for b in image_data)

    return image_data

def get_bit(image_data, row_bytes, x, y):
    byte_index = y * row_bytes + (x // 8)
    bit_mask = 0x80 >> (x % 8)
    return bool(image_data[byte_index] & bit_mask)

def set_bit(image_data, row_bytes, x, y):
    byte_index = y * row_bytes + (x // 8)
    bit_mask = 0x80 >> (x % 8)
    image_data[byte_index] |= bit_mask

def find_content_bounds(image_data, width, height):
    row_bytes = (width + 7) // 8
    min_x, min_y = width, height
    max_x, max_y = -1, -1

    for y in range(height):
        row = image_data[y * row_bytes:(y + 1) * row_bytes]
        if not any(row):
            continue

        min_y = min(min_y, y)
        max_y = max(max_y, y)

        for byte_offset, byte_val in enumerate(row):
            if byte_val == 0:
                continue
            x_base = byte_offset * 8
            for bit in range(8):
                x = x_base + bit
                if x >= width:
                    break
                if byte_val & (0x80 >> bit):
                    min_x = min(min_x, x)
                    max_x = max(max_x, x)

    if max_x < 0 or max_y < 0:
        return 0, 0, width - 1, height - 1

    pad = max(0, CONTENT_PAD_PX)
    return (
        max(0, min_x - pad),
        max(0, min_y - pad),
        min(width - 1, max_x + pad),
        min(height - 1, max_y + pad),
    )

def crop_bitmap(image_data, width, height, bounds):
    x1, y1, x2, y2 = bounds
    crop_w = x2 - x1 + 1
    crop_h = y2 - y1 + 1
    src_row_bytes = (width + 7) // 8
    dst_row_bytes = (crop_w + 7) // 8
    dst = bytearray(dst_row_bytes * crop_h)

    for y in range(crop_h):
        src_y = y1 + y
        for x in range(crop_w):
            src_x = x1 + x
            if get_bit(image_data, src_row_bytes, src_x, src_y):
                set_bit(dst, dst_row_bytes, x, y)

    return bytes(dst), crop_w, crop_h

def rotate_bitmap_cw(image_data, width, height):
    src_row_bytes = (width + 7) // 8
    out_w, out_h = height, width
    out_row_bytes = (out_w + 7) // 8
    out = bytearray(out_row_bytes * out_h)

    for y in range(height):
        for x in range(width):
            if get_bit(image_data, src_row_bytes, x, y):
                out_x = height - 1 - y
                out_y = x
                set_bit(out, out_row_bytes, out_x, out_y)

    return bytes(out), out_w, out_h

def fit_bitmap_top_center(image_data, width, height, target_w, target_h, zoom):
    src_row_bytes = (width + 7) // 8
    dst_row_bytes = (target_w + 7) // 8
    dst = bytearray(dst_row_bytes * target_h)

    if width <= 0 or height <= 0:
        return bytes(dst), target_w, target_h

    fit_scale = min(target_w / width, target_h / height)
    if not ALLOW_UPSCALE:
        fit_scale = min(1.0, fit_scale)
    scale = fit_scale
    scale *= zoom if zoom and zoom > 0 else 1.0

    scaled_w = max(1, int(round(width * scale)))
    scaled_h = max(1, int(round(height * scale)))

    offset_x = (target_w - scaled_w) // 2
    offset_y = 0  # top-anchored by design

    x_start = max(0, offset_x)
    x_end = min(target_w, offset_x + scaled_w)
    y_start = max(0, offset_y)
    y_end = min(target_h, offset_y + scaled_h)

    if x_start >= x_end or y_start >= y_end:
        return bytes(dst), target_w, target_h

    for y in range(y_start, y_end):
        src_y = int((y - offset_y) / scale)
        if src_y < 0 or src_y >= height:
            continue
        for x in range(x_start, x_end):
            src_x = int((x - offset_x) / scale)
            if src_x < 0 or src_x >= width:
                continue
            if get_bit(image_data, src_row_bytes, src_x, src_y):
                set_bit(dst, dst_row_bytes, x, y)

    return bytes(dst), target_w, target_h

def normalize_label_bitmap(image_data, width, height):
    row_bytes = (width + 7) // 8
    image_data = normalize_image_data(image_data, row_bytes, height)

    if AUTO_CROP_CONTENT:
        bounds = find_content_bounds(image_data, width, height)
        image_data, width, height = crop_bitmap(image_data, width, height, bounds)
        log(f"Cropped to content: {width}x{height}")

    if ROTATE_TO_FIT:
        src_landscape = width > height
        target_landscape = WIDTH_PX > HEIGHT_PX
        if src_landscape != target_landscape:
            image_data, width, height = rotate_bitmap_cw(image_data, width, height)
            log(f"Rotated bitmap to: {width}x{height}")

    image_data, width, height = fit_bitmap_top_center(
        image_data,
        width,
        height,
        WIDTH_PX,
        HEIGHT_PX,
        CONTENT_ZOOM,
    )
    log(f"Fitted bitmap to label canvas: {width}x{height}")
    return image_data, width, height

def process_pbm_data(data):
    """Parse PBM file data and emit ZPL."""
    # PBM file format (P4)
    if len(data) < 3:
        return

    if data[:2] != b"P4":
        sys.stderr.write("ERROR: Not a P4 PBM file\n")
        return

    offset = 2
    while offset < len(data) and chr(data[offset]).isspace():
        offset += 1

    while offset < len(data) and chr(data[offset]) == "#":
        while offset < len(data) and chr(data[offset]) != "\n":
            offset += 1
        offset += 1
        while offset < len(data) and chr(data[offset]).isspace():
            offset += 1

    w_start = offset
    while offset < len(data) and not chr(data[offset]).isspace():
        offset += 1
    if offset >= len(data):
        return
    width = int(data[w_start:offset])

    while offset < len(data) and chr(data[offset]).isspace():
        offset += 1

    h_start = offset
    while offset < len(data) and not chr(data[offset]).isspace():
        offset += 1
    if offset >= len(data):
        return
    height = int(data[h_start:offset])

    while offset < len(data) and chr(data[offset]).isspace():
        offset += 1

    image_data = data[offset:]
    image_data, width, height = normalize_label_bitmap(image_data, width, height)
    row_bytes = (width + 7) // 8
    image_data = maybe_transform_image(image_data, row_bytes, height)

    log(f"PBM {width}x{height}, row_bytes={row_bytes}, bytes={len(image_data)}")
    emit_zpl(width, height, row_bytes, image_data)

def emit_zpl(width, height, row_bytes, data):
    """Output ZPL for a single image."""
    sys.stdout.buffer.write(b"^XA")
    sys.stdout.buffer.write(b"^PW%d" % width)
    sys.stdout.buffer.write(b"^LL%d" % height)
    sys.stdout.buffer.write(b"^PON")

    hex_data = data.hex().upper().encode("ascii")
    sys.stdout.buffer.write(b"^FO0,0^GFA,%d,%d,%d," % (len(data), len(data), row_bytes))
    sys.stdout.buffer.write(hex_data)
    sys.stdout.buffer.write(b"^FS")
    sys.stdout.buffer.write(b"^XZ\n")

def pdf_to_zpl(input_path, job_id, user, title, copies, options):
    """Convert PDF or PS to ZPL."""
    if not require_tool("pdftoppm", "Install poppler-utils."):
        return 1

    temp_dir = tempfile.mkdtemp(prefix="cups_zpl_")
    try:
        if input_path and input_path != "-":
            source_path = input_path
        else:
            source_path = os.path.join(temp_dir, "input")
            input_data = sys.stdin.buffer.read()
            if len(input_data) == 0:
                sys.stderr.write("ERROR: No input data received on stdin\n")
                return 1
            with open(source_path, "wb") as f:
                f.write(input_data)

        file_type = sniff_file_type(source_path)
        log(f"Input type: {file_type}")

        if file_type == "ps":
            pdf_path = os.path.join(temp_dir, "input.pdf")
            if not ps_to_pdf(source_path, pdf_path):
                return 1
        else:
            pdf_path = source_path

        if FIT_TO_LABEL and file_type in ("ps", "pdf"):
            fit_path = os.path.join(temp_dir, "fit.pdf")
            if prepare_pdf_for_label(pdf_path, fit_path):
                pdf_path = fit_path

        pbm_files = render_pdf_to_pbm(pdf_path, temp_dir)
        if not pbm_files:
            sys.stderr.write(f"ERROR: No PBM files generated in {temp_dir}\n")
            return 1

        for pbm_file in pbm_files:
            with open(pbm_file, "rb") as f:
                data = f.read()
                process_pbm_data(data)

    except Exception as e:
        sys.stderr.write(f"ERROR: Conversion failed: {e}\n")
        return 1
    finally:
        shutil.rmtree(temp_dir)
    return 0

if __name__ == "__main__":
    if len(sys.argv) < 6:
        sys.stderr.write("Usage: pdftozpl job-id user title copies options [file]\n")

    job_id = sys.argv[1] if len(sys.argv) > 1 else "1"
    user = sys.argv[2] if len(sys.argv) > 2 else "unknown"
    title = sys.argv[3] if len(sys.argv) > 3 else "untitled"
    copies = sys.argv[4] if len(sys.argv) > 4 else "1"
    options = sys.argv[5] if len(sys.argv) > 5 else ""
    filename = sys.argv[6] if len(sys.argv) > 6 else None

    sys.exit(pdf_to_zpl(filename, job_id, user, title, copies, options))
